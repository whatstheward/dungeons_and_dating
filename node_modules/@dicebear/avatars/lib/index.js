"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var random_1 = require("./random");
var color_1 = require("./color");
var parser_1 = require("./parser");
var Avatars = /** @class */ (function () {
    /**
     * @param spriteCollection
     */
    function Avatars(spriteCollection, defaultOptions) {
        this.spriteCollection = spriteCollection;
        this.defaultOptions = __assign({ userAgent: typeof window !== 'undefined' && window.navigator && window.navigator.userAgent }, defaultOptions);
    }
    /**
     * Creates an avatar
     *
     * @param seed
     */
    Avatars.prototype.create = function (seed, options) {
        var _this = this;
        options = __assign(__assign({}, this.defaultOptions), options);
        var svg = this.spriteCollection(new random_1.default(seed), options);
        if (options) {
            svg = parser_1.default.parse(svg);
            var viewBox = svg.attributes['viewBox'].split(' ');
            var viewBoxX = parseInt(viewBox[0]);
            var viewBoxY = parseInt(viewBox[1]);
            var viewBoxWidth = parseInt(viewBox[2]);
            var viewBoxHeight = parseInt(viewBox[3]);
            if (options.width) {
                svg.attributes['width'] = options.width.toString();
            }
            if (options.height) {
                svg.attributes['height'] = options.height.toString();
            }
            if (options.margin) {
                var groupable_1 = [];
                svg.children = svg.children.filter(function (child) {
                    if (_this.isGroupable(child)) {
                        groupable_1.push(child);
                        return false;
                    }
                    return true;
                });
                svg.children.push({
                    name: 'g',
                    type: 'element',
                    value: '',
                    children: [
                        {
                            name: 'g',
                            type: 'element',
                            value: '',
                            children: __spreadArrays([
                                {
                                    name: 'rect',
                                    type: 'element',
                                    value: '',
                                    children: [],
                                    attributes: {
                                        fill: 'none',
                                        width: viewBoxWidth.toString(),
                                        height: viewBoxHeight.toString(),
                                        x: viewBoxX.toString(),
                                        y: viewBoxY.toString()
                                    }
                                }
                            ], groupable_1),
                            attributes: {
                                transform: "scale(" + (1 - (options.margin * 2) / 100) + ")"
                            }
                        }
                    ],
                    attributes: {
                        // prettier-ignore
                        transform: "translate(" + viewBoxWidth * options.margin / 100 + ", " + viewBoxHeight * options.margin / 100 + ")"
                    }
                });
            }
            if (options.background) {
                svg.children.unshift({
                    name: 'rect',
                    type: 'element',
                    value: '',
                    children: [],
                    attributes: {
                        fill: options.background,
                        width: viewBoxWidth.toString(),
                        height: viewBoxHeight.toString(),
                        x: viewBoxX.toString(),
                        y: viewBoxY.toString()
                    }
                });
            }
            if (options.radius) {
                var groupable_2 = [];
                svg.children = svg.children.filter(function (child) {
                    if (_this.isGroupable(child)) {
                        groupable_2.push(child);
                        return false;
                    }
                    return true;
                });
                svg.children.push({
                    name: 'mask',
                    type: 'element',
                    value: '',
                    children: [
                        {
                            name: 'rect',
                            type: 'element',
                            value: '',
                            children: [],
                            attributes: {
                                width: viewBoxWidth.toString(),
                                height: viewBoxHeight.toString(),
                                rx: ((viewBoxWidth * options.radius) / 100).toString(),
                                ry: ((viewBoxHeight * options.radius) / 100).toString(),
                                fill: '#fff',
                                x: viewBoxX.toString(),
                                y: viewBoxY.toString()
                            }
                        }
                    ],
                    attributes: {
                        id: 'avatarsRadiusMask'
                    }
                }, {
                    name: 'g',
                    type: 'element',
                    value: '',
                    children: groupable_2,
                    attributes: {
                        mask: "url(#avatarsRadiusMask)"
                    }
                });
            }
        }
        svg = parser_1.default.stringify(svg);
        return options && options.base64 ? "data:image/svg+xml;base64," + this.base64EncodeUnicode(svg) : svg;
    };
    Avatars.prototype.isGroupable = function (element) {
        return element.type === 'element' && ['title', 'desc', 'defs', 'metadata'].indexOf(element.name) === -1;
    };
    Avatars.prototype.base64EncodeUnicode = function (value) {
        // @see https://www.base64encoder.io/javascript/
        var utf8Bytes = encodeURIComponent(value).replace(/%([0-9A-F]{2})/g, function (match, p1) {
            return String.fromCharCode(parseInt("0x" + p1));
        });
        return btoa(utf8Bytes);
    };
    Avatars.random = random_1.default;
    Avatars.color = color_1.default;
    return Avatars;
}());
exports.default = Avatars;
//# sourceMappingURL=index.js.map